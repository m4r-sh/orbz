var S=function(W,z){let G=new Set([...W].filter((H)=>!z.has(H))),q=new Set([...z].filter((H)=>!W.has(H))),J={};Array.from([...z]).forEach((H)=>{if(H.indexOf(".")>0){let K=H.substring(0,H.indexOf(".")),X=H.substring(H.indexOf(".")+1);if(J[K])J[K].add(X);else J[K]=new Set([X]);q.delete(H)}});let B=Object.keys(J).map((H)=>[H,J[H]]);return[G,q,B]},F=0,P=[],Y=null,j="",w=Symbol("orbz-core");class R{#J(){return Y==this||!this.#N}#U(W){let z=P.length;if(z!=0)P[z-1].add(j+W),j=""}#P(){P.push(new Set)}#R(){return P.splice(P.length-1,1)[0]}#F(W){if(this.#Q[W])return this.#x[W];else{this.#P();let z=this.#H[W],G=this.#A[W](),q=this.#R(),[J,B,H]=S(z,q);return J.forEach((K)=>{this.#W[K].delete(W),this.#H[W].delete(K)}),B.forEach((K)=>{if(this.#W[K])this.#W[K].add(W);this.#H[W].add(K)}),H.forEach(([K,X])=>{this.#z[K].$((V)=>{})}),this.#x[W]=G,this.#Q[W]=!0,G}}#T(W,z=!1){if(this.#N){if(z||this.#Q[W]){if(this.#K.add(W),!z)this.#Q[W]=!1;this.#W[W].forEach((G)=>this.#T(G))}}}#X(){if(F==0&&this.#K.size>0)this.#G.forEach((W,z)=>{if(W==null||[...W].some((G)=>this.#K.has(G))){W=new Set,this.#P(),z(this.#q);let G=this.#R(),[q,J,B]=S(W,G);if(q.forEach((H)=>{W.delete(H)}),J.forEach((H)=>{W.add(H)}),B.forEach(([H,K])=>{}),W.size==0)this.#G.delete(z);else this.#G.set(z,W)}}),this.#K.clear()}#V={};#Y={};#z={};#K=new Set;#x={};#Q={};#A={};#B={};#q;#G=new Map;#W={};#H={};#I={};#N=!1;constructor(W,z,G){this.#q=G,this.#V=W.orbs;for(let q in W.state)this.#W[q]=new Set,this.set_state(q,q in z?z[q]:structuredClone(W.state[q]));for(let q in W.orbs)this.#W[q]=new Set,this.set_orb(q,z[q]);for(let q in W.entry)this.#B[q]=W.entry[q].bind(this.#q);for(let q in W.async)this.#B[q]=W.async[q].bind(this.#q);for(let q in W.derived)this.#W[q]=new Set,this.#H[q]=new Set,this.#A[q]=W.derived[q].bind(this.#q);for(let q in W.getset)this.#W[q]=new Set,this.#H[q]=new Set,this.#A[q]=W.getset[q].get.bind(this.#q),this.#B[q]=W.getset[q].set.bind(this.#q);this.#N=!0}add_link(W,z){let G=this.#I[W];return(q)=>{return G.add(q),()=>{G.delete(q)}}}add_sub(W,z){return this.#G.set(W,null),()=>{this.#G.delete(W)}}get_state(W){if(!W.startsWith("_")||this.#J())return this.#U(W),this.#Y[W]}set_state(W,z){if(!W.startsWith("_")||this.#J()){if(z!=this.#Y[W])this.#Y[W]=z,this.#T(W,!0),this.#X()}}get_derived(W){if(!W.startsWith("_")||this.#J()){this.#U(W);let z;const G=Y;Y=this;try{z=this.#F(W)}finally{Y=G}return z}}run_entrypoint(W,z,{async:G=!1}={}){if(!W.startsWith("_")||this.#J()){if(this.#B[W]){let q;const J=Y;if(!G)Y=this,F++;try{q=this.#B[W](...z)}finally{Y=J}if(G)return q.then((B)=>{return this.#X(),B});else return F--,this.#X(),q}}}set_orb(W,z){let G=this.#V[W];if(z&&z instanceof G)this.#z[W]=z;else if(z&&typeof z=="object")this.#z[W]=new G({...z});else this.#z[W]=null}get_orb(W){return this.#U(W),this.#z[W]}}var Q=Symbol("orb-core"),p=Symbol("list-core"),T=Symbol("m-self"),h=Symbol("orbz-ismodel"),N=Symbol("model-def"),A=Symbol("model-id"),x=Symbol("model-id");var U=function(){let{defs:W,types:z}=$(arguments[arguments.length-1]),G=Symbol("unique-model-id"),q=[G];for(let B=arguments.length-2;B>=0;B--)W=m(arguments[B][N],W),q.push(...arguments[B][A]);function J(B={}){if(!new.target)return new J(B);Object.defineProperty(this,Q,{value:new R(W,B,this)}),Object.defineProperty(this,x,{value:q}),Object.preventExtensions(this)}return Object.defineProperty(J,Symbol.hasInstance,{value:function(B){return B&&B[x]&&B[x].includes(G)}}),J[N]=W,J[A]=q,J.toString=function(){return O(W)},Object.keys(W.orbs).forEach((B)=>{if(W.orbs[B]==T)W.orbs[B]=J}),Object.keys(W.entry).forEach((B)=>{Object.defineProperty(J.prototype,B,{value:function(){return this[Q].run_entrypoint(B,arguments,{async:!1})}})}),Object.keys(W.async).forEach((B)=>{Object.defineProperty(J.prototype,B,{value:function(){return this[Q].run_entrypoint(B,arguments,{async:!0})}})}),Object.keys(W.derived).forEach((B)=>{Object.defineProperty(J.prototype,B,{get(){return this[Q].get_derived(B)},enumerable:!B.startsWith("_")})}),Object.keys(W.getset).forEach((B)=>{Object.defineProperty(J.prototype,B,{get(){return this[Q].get_derived(B)},set(H){return this[Q].run_entrypoint(B,[H])},enumerable:!B.startsWith("_")})}),Object.keys(W.state).forEach((B)=>{Object.defineProperty(J.prototype,B,{get(){return this[Q].get_state(B)},set(H){this[Q].set_state(B,H)},enumerable:!B.startsWith("_")})}),Object.keys(W.orbs).forEach((B)=>{Object.defineProperty(J.prototype,B,{get(){return this[Q].get_orb(B)},set(H){this[Q].set_orb(B,H)},enumerable:!B.startsWith("_")})}),Object.defineProperties(J.prototype,D),J},$=function(W){let z={state:{},derived:{},entry:{},orbs:{},getset:{},async:{}},G={},q=Object.getOwnPropertyDescriptors(W);return Object.keys(q).forEach((J)=>{let B,H,{value:K,get:X,set:V}=q[J];if(X&&V)B="getset",H={get:X,set:V};else if(X)H=X,B="derived";else if(V)console.log("TODO: lone setter");else if(H=K,typeof K=="function")if(K instanceof U)B="orbs";else if(K.constructor.name=="AsyncFunction")B="async";else B="entry";else if(K==T)B="orbs";else B="state";G[J]=B,z[B][J]=H}),{types:G,defs:z}},m=function(W,z){const G={...W,...z};for(let q of Object.keys(G))G[q]=typeof W[q]=="object"&&typeof z[q]=="object"?m(W[q],z[q]):G[q];return G};function O({state:W,derived:z,entry:G,orbs:q,getset:J,async:B}){let H="{\n";return H+=Object.keys(W).map((K)=>`${K}:${I(W[K],K)}`).join(",\n"),H+=",\n",H+=Object.keys(z).map((K)=>`${z[K]}`).join(",\n"),H+=",\n",H+=Object.keys(G).map((K)=>`${G[K]}`).join(",\n"),H+=",\n",H+="}",H}var D={$:{value:function(W,z){if(typeof W=="function")return this[Q].add_sub(W,z);else if(typeof W=="string")return this[Q].add_link(W,z)}},$invalidate:{value:function(W){this[Q].inval(W)}}};U.self=()=>T;U.stringify=function(W){return O(W[N])};Object.defineProperty(U,Symbol.hasInstance,{value(W){return W&&Object.hasOwn(W,A)}});Object.defineProperty(U,"toString",{value(W){return W&&Object.hasOwn(W,A)}});/*! (c) Andrea Giammarchi - ISC */var L=(W)=>"{"+Object.keys(W).map((z)=>{const{get:G,set:q,value:J}=Object.getOwnPropertyDescriptor(W,z);if(G&&q)z=G+","+q;else if(G)z=""+G;else if(q)z=""+q;else z=JSON.stringify(z)+":"+I(J,z);return z}).join(",")+"}",I=(W,z)=>{const G=typeof W;if(G==="function")return W.toString().replace(new RegExp("^(\\*|async )?\\s*"+z+"[^(]*?\\("),(q,J)=>J==="*"?"function* (":(J||"")+"function (");if(G==="object"&&W)return Array.isArray(W)?E(W):L(W);return JSON.stringify(W)},E=(W)=>"["+W.map(I).join(",")+"]";var C=function(W){return U(W)()};Object.defineProperty(C,Symbol.hasInstance,{value(W){return W&&W[Q]&&W[Q]instanceof R}});function Z(W){return{def:W[N],models:W[A]}}export{Z as inspect,C as Orb,U as Model};
