var S=function(z,B){let H=new Set([...z].filter((J)=>!B.has(J))),q=new Set([...B].filter((J)=>!z.has(J))),K={};Array.from([...B]).forEach((J)=>{if(J.indexOf(".")>0){let Q=J.substring(0,J.indexOf(".")),X=J.substring(J.indexOf(".")+1);if(K[Q])K[Q].add(X);else K[Q]=new Set([X]);q.delete(J)}});let G=Object.keys(K).map((J)=>[J,K[J]]);return[H,q,G]},I=0,A=[],Y=null,x="",w=Symbol("orbz-core");class R{#A={};#W={};#B={};#K=new Set;#R={};#Q={};#X={};#G={};#q;#H=new Map;#z={};#J={};#I={};#Y=!1;#U(){return Y==this||!this.#Y}#N(z){let B=A.length;if(B!=0)A[B-1].add(x+z),x=""}#T(){A.push(new Set)}#V(){return A.splice(A.length-1,1)[0]}#j(z){if(this.#Q[z])return this.#R[z];else{this.#T();let B=this.#J[z],H=this.#X[z](),q=this.#V(),[K,G,J]=S(B,q);return K.forEach((Q)=>{this.#z[Q].delete(z),this.#J[z].delete(Q)}),G.forEach((Q)=>{if(this.#z[Q])this.#z[Q].add(z);this.#J[z].add(Q)}),J.forEach(([Q,X])=>{this.#B[Q].$((V)=>{})}),this.#R[z]=H,this.#Q[z]=!0,H}}#F(z,B=!1){if(this.#Y){if(B||this.#Q[z]){if(this.#K.add(z),!B)this.#Q[z]=!1;this.#z[z].forEach((H)=>this.#F(H))}}}#P(){if(I==0&&this.#K.size>0)this.#H.forEach((z,B)=>{if(z==null||[...z].some((H)=>this.#K.has(H))){z=new Set,this.#T(),B(this.#q);let H=this.#V(),[q,K,G]=S(z,H);if(q.forEach((J)=>{z.delete(J)}),K.forEach((J)=>{z.add(J)}),G.forEach(([J,Q])=>{}),z.size==0)this.#H.delete(B);else this.#H.set(B,z)}}),this.#K.clear()}constructor(z,B,H){this.#q=H,this.#A=z.orbs;for(let q in z.state)this.#z[q]=new Set,this.set_state(q,q in B?B[q]:structuredClone(z.state[q]));for(let q in z.orbs)this.#z[q]=new Set,this.set_orb(q,B[q]);for(let q in z.entry)this.#G[q]=z.entry[q].bind(this.#q);for(let q in z.async)this.#G[q]=z.async[q].bind(this.#q);for(let q in z.derived)this.#z[q]=new Set,this.#J[q]=new Set,this.#X[q]=z.derived[q].bind(this.#q);for(let q in z.getset)this.#z[q]=new Set,this.#J[q]=new Set,this.#X[q]=z.getset[q].get.bind(this.#q),this.#G[q]=z.getset[q].set.bind(this.#q);this.#Y=!0}add_link(z,B){let H=this.#I[z];return(q)=>{return H.add(q),()=>{H.delete(q)}}}add_sub(z,B){return this.#H.set(z,null),()=>{this.#H.delete(z)}}get_state(z){if(!z.startsWith("_")||this.#U())return this.#N(z),this.#W[z]}set_state(z,B){if(!z.startsWith("_")||this.#U()){if(B!=this.#W[z])this.#W[z]=B,this.#F(z,!0),this.#P()}}get_derived(z){if(!z.startsWith("_")||this.#U()){this.#N(z);let B;const H=Y;Y=this;try{B=this.#j(z)}finally{Y=H}return B}}run_entrypoint(z,B,{async:H=!1}={}){if(!z.startsWith("_")||this.#U()){if(this.#G[z]){let q;const K=Y;if(!H)Y=this,I++;try{q=this.#G[z](...B)}finally{Y=K}if(H)return q.then((G)=>{return this.#P(),G});else return I--,this.#P(),q}}}set_orb(z,B){let H=this.#A[z];if(B&&B instanceof H)this.#B[z]=B;else if(B&&typeof B=="object")this.#B[z]=new H({...B});else this.#B[z]=null}get_orb(z){return this.#N(z),this.#B[z]}}var U=Symbol.for("orbz-orb-core"),p=Symbol.for("orbz-list-core"),T=Symbol.for("orbz-m-self"),h=Symbol.for("orbz-orbz-ismodel"),P=Symbol.for("orbz-model-def"),N=Symbol.for("orbz-model-id"),F=Symbol.for("orbz-model-implements");var W=function(){let{defs:z,types:B}=$(arguments[arguments.length-1]),H=Symbol("unique-model-id"),q=[H];for(let G=arguments.length-2;G>=0;G--)z=m(arguments[G][P],z),q.push(...arguments[G][N]);function K(G={}){if(!new.target)return new K(G);Object.defineProperty(this,U,{value:new R(z,G,this)}),Object.defineProperty(this,F,{value:q}),Object.preventExtensions(this)}return Object.defineProperty(K,Symbol.hasInstance,{value:function(G){return G&&G[F]&&G[F].includes(H)}}),K[P]=z,K[N]=q,K.toString=function(){return O(z)},Object.keys(z.orbs).forEach((G)=>{if(z.orbs[G]==T)z.orbs[G]=K}),Object.keys(z.entry).forEach((G)=>{Object.defineProperty(K.prototype,G,{value:function(){return this[U].run_entrypoint(G,arguments,{async:!1})}})}),Object.keys(z.async).forEach((G)=>{Object.defineProperty(K.prototype,G,{value:function(){return this[U].run_entrypoint(G,arguments,{async:!0})}})}),Object.keys(z.derived).forEach((G)=>{Object.defineProperty(K.prototype,G,{get(){return this[U].get_derived(G)},enumerable:!G.startsWith("_")})}),Object.keys(z.getset).forEach((G)=>{Object.defineProperty(K.prototype,G,{get(){return this[U].get_derived(G)},set(J){return this[U].run_entrypoint(G,[J])},enumerable:!G.startsWith("_")})}),Object.keys(z.state).forEach((G)=>{Object.defineProperty(K.prototype,G,{get(){return this[U].get_state(G)},set(J){this[U].set_state(G,J)},enumerable:!G.startsWith("_")})}),Object.keys(z.orbs).forEach((G)=>{Object.defineProperty(K.prototype,G,{get(){return this[U].get_orb(G)},set(J){this[U].set_orb(G,J)},enumerable:!G.startsWith("_")})}),Object.defineProperties(K.prototype,D),K},$=function(z){let B={state:{},derived:{},entry:{},orbs:{},getset:{},async:{}},H={},q=Object.getOwnPropertyDescriptors(z);return Object.keys(q).forEach((K)=>{let G,J,{value:Q,get:X,set:V}=q[K];if(X&&V)G="getset",J={get:X,set:V};else if(X)J=X,G="derived";else if(V)console.log("TODO: lone setter");else if(J=Q,typeof Q=="function")if(Q instanceof W)G="orbs";else if(Q.constructor.name=="AsyncFunction")G="async";else G="entry";else if(Q==T)G="orbs";else G="state";H[K]=G,B[G][K]=J}),{types:H,defs:B}},m=function(z,B){const H={...z,...B};for(let q of Object.keys(H))H[q]=typeof z[q]=="object"&&typeof B[q]=="object"?m(z[q],B[q]):H[q];return H};function O({state:z,derived:B,entry:H,orbs:q,getset:K,async:G}){let J="{\n";return J+=Object.keys(z).map((Q)=>`${Q}:${j(z[Q],Q)}`).join(",\n"),J+=",\n",J+=Object.keys(B).map((Q)=>`${B[Q]}`).join(",\n"),J+=",\n",J+=Object.keys(H).map((Q)=>`${H[Q]}`).join(",\n"),J+=",\n",J+="}",J}var D={$:{value:function(z,B){if(typeof z=="function")return this[U].add_sub(z,B);else if(typeof z=="string")return this[U].add_link(z,B)}},$invalidate:{value:function(z){this[U].inval(z)}}};W.self=()=>T;W.stringify=function(z){return O(z[P])};Object.defineProperty(W,Symbol.hasInstance,{value(z){return z&&Object.hasOwn(z,N)}});Object.defineProperty(W,"toString",{value(z){return z&&Object.hasOwn(z,N)}});/*! (c) Andrea Giammarchi - ISC */var L=(z)=>"{"+Object.keys(z).map((B)=>{const{get:H,set:q,value:K}=Object.getOwnPropertyDescriptor(z,B);if(H&&q)B=H+","+q;else if(H)B=""+H;else if(q)B=""+q;else B=JSON.stringify(B)+":"+j(K,B);return B}).join(",")+"}",j=(z,B)=>{const H=typeof z;if(H==="function")return z.toString().replace(new RegExp("^(\\*|async )?\\s*"+B+"[^(]*?\\("),(q,K)=>K==="*"?"function* (":(K||"")+"function (");if(H==="object"&&z)return Array.isArray(z)?E(z):L(z);return JSON.stringify(z)},E=(z)=>"["+z.map(j).join(",")+"]";var C=function(z){return W(z)()};Object.defineProperty(C,Symbol.hasInstance,{value(z){return z&&z[U]&&z[U]instanceof R}});function Z(z){return{def:z[P],models:z[N]}}export{Z as inspect,C as Orb,W as Model};
