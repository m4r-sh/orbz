var j=function(q,G){let H=new Set([...q].filter((J)=>!G.has(J))),B=new Set([...G].filter((J)=>!q.has(J))),K={};Array.from([...G]).forEach((J)=>{if(J.indexOf(".")>0){let Q=J.substring(0,J.indexOf(".")),V=J.substring(J.indexOf(".")+1);if(K[Q])K[Q].add(V);else K[Q]=new Set([V]);B.delete(J)}});let z=Object.keys(K).map((J)=>[J,K[J]]);return[H,B,z]},F=0,Y=[],I=null,x="",D=Symbol("orbz-core");class P{#Y={};#U={};#B={};#V=new Set;#P={};#K={};#W={};#G={};#z;#H=new Map;#q={};#J={};#F={};constructor(q,G,H){this.#z=H,this.#Y=q.orbs;for(let B in q.state)this.#q[B]=new Set,this.set_state(B,B in G?G[B]:structuredClone(q.state[B]));for(let B in q.orbs)this.#q[B]=new Set,this.set_orb(B,G[B]);for(let B in q.entry)this.#G[B]=q.entry[B].bind(this.#z);for(let B in q.async)this.#G[B]=q.async[B].bind(this.#z);for(let B in q.derived)this.#q[B]=new Set,this.#J[B]=new Set,this.#W[B]=q.derived[B].bind(this.#z);for(let B in q.getset)this.#q[B]=new Set,this.#J[B]=new Set,this.#W[B]=q.getset[B].get.bind(this.#z),this.#G[B]=q.getset[B].set.bind(this.#z)}add_link(q,G){let H=this.#F[q];return(B)=>{return H.add(B),()=>{H.delete(B)}}}add_sub(q,G){return this.#H.set(q,null),()=>{this.#H.delete(q)}}get_state(q){if(!q.startsWith("_")||this.#Q())return this.#N(q),this.#U[q]}set_state(q,G){if(!q.startsWith("_")||this.#Q()){if(G!=this.#U[q])this.#U[q]=G,this.#A(q,!0),this.#X()}}get_derived(q){if(!q.startsWith("_")||this.#Q()){this.#N(q);const G=I;let H;I=this;try{H=this.#I(q)}finally{I=G}return H}}run_entrypoint(q,G,{async:H=!1}={}){if(!q.startsWith("_")||this.#Q()){if(this.#G[q]){if(!H)F++;let B=this.#G[q](...G);if(H)return B.then((K)=>{return this.#X(),K});else return F--,this.#X(),B}}}set_orb(q,G){let H=this.#Y[q];if(G&&G instanceof H)this.#B[q]=G;else if(G&&typeof G=="object")this.#B[q]=new H({...G});else this.#B[q]=null}get_orb(q){return this.#B[q]}#Q(){return!0}#N(q){let G=Y.length;if(G!=0)Y[G-1].add(x+q),x=""}#R(){Y.push(new Set)}#T(){return Y.splice(Y.length-1,1)[0]}#I(q){if(this.#K[q])return this.#P[q];else{this.#R();let G=this.#J[q],H=this.#W[q](),B=this.#T(),[K,z,J]=j(G,B);return K.forEach((Q)=>{this.#q[Q].delete(q),this.#J[q].delete(Q)}),z.forEach((Q)=>{if(this.#q[Q])this.#q[Q].add(q);this.#J[q].add(Q)}),J.forEach(([Q,V])=>{this.#B[Q].$((T)=>{})}),this.#P[q]=H,this.#K[q]=!0,H}}#A(q,G=!1){if(G||this.#K[q]){if(this.#V.add(q),!G)this.#K[q]=!1;this.#q[q].forEach((H)=>this.#A(H))}}#X(){if(F==0)this.#H.forEach((q,G)=>{if(q==null||[...q].some((H)=>this.#V.has(H))){q=new Set,this.#H.set(G,q),this.#R(),G(this.#z);let H=this.#T(),[B,K,z]=j(q,H);if(B.forEach((J)=>{q.delete(J)}),K.forEach((J)=>{q.add(J)}),z.forEach(([J,Q])=>{}),q.size==0)this.#H.delete(G)}}),this.#V.clear()}}var U=Symbol("orb-core"),E=Symbol("list-core"),N=Symbol("m-self"),Z=Symbol("orbz-ismodel"),R=Symbol("model-def"),X=Symbol("model-id"),A=Symbol("model-id");var W=function(){let{defs:q,types:G}=S(arguments[arguments.length-1]),H=Symbol("unique-model-id"),B=[H];for(let z=arguments.length-2;z>=0;z--)q=O(arguments[z][R],q),B.push(...arguments[z][X]);function K(z={}){if(!new.target)return new K(z);Object.defineProperty(this,U,{value:new P(q,z,this)}),Object.defineProperty(this,A,{value:B}),Object.preventExtensions(this)}return Object.defineProperty(K,Symbol.hasInstance,{value:function(z){return z&&z[A]&&z[A].includes(H)}}),K[R]=q,K[X]=B,Object.keys(q.orbs).forEach((z)=>{if(q.orbs[z]==N)q.orbs[z]=K}),Object.keys(q.entry).forEach((z)=>{Object.defineProperty(K.prototype,z,{value:function(){return this[U].run_entrypoint(z,arguments,{async:!1})}})}),Object.keys(q.async).forEach((z)=>{Object.defineProperty(K.prototype,z,{value:function(){return this[U].run_entrypoint(z,arguments,{async:!0})}})}),Object.keys(q.derived).forEach((z)=>{Object.defineProperty(K.prototype,z,{get(){return this[U].get_derived(z)},enumerable:!z.startsWith("_")})}),Object.keys(q.getset).forEach((z)=>{Object.defineProperty(K.prototype,z,{get(){return this[U].get_derived(z)},set(J){return this[U].run_entrypoint(z,[J])},enumerable:!z.startsWith("_")})}),Object.keys(q.state).forEach((z)=>{Object.defineProperty(K.prototype,z,{get(){return this[U].get_state(z)},set(J){this[U].set_state(z,J)},enumerable:!z.startsWith("_")})}),Object.keys(q.orbs).forEach((z)=>{Object.defineProperty(K.prototype,z,{get(){return this[U].get_orb(z)},set(J){this[U].set_orb(z,J)},enumerable:!z.startsWith("_")})}),Object.defineProperties(K.prototype,C),K},S=function(q){let G={state:{},derived:{},entry:{},orbs:{},getset:{},async:{}},H={},B=Object.getOwnPropertyDescriptors(q);return Object.keys(B).forEach((K)=>{let z,J,{value:Q,get:V,set:T}=B[K];if(V&&T)z="getset",J={get:V,set:T};else if(V)J=V,z="derived";else if(T)console.log("TODO: lone setter");else if(J=Q,typeof Q=="function")if(Q instanceof W)z="orbs";else if(Q.constructor.name=="AsyncFunction")z="async";else z="entry";else if(Q==N)z="orbs";else z="state";H[K]=z,G[z][K]=J}),{types:H,defs:G}},O=function(q,G){const H={...q,...G};for(let B of Object.keys(H))H[B]=typeof q[B]=="object"&&typeof G[B]=="object"?O(q[B],G[B]):H[B];return H},C={$:{value:function(q,G){if(typeof q=="function")return this[U].add_sub(q,G);else if(typeof q=="string")return this[U].add_link(q,G)}},$invalidate:{value:function(q){this[U].inval(q)}},toString:{value:function(){return"orb toString"}},[Symbol.toPrimitive]:{value:function(){return"orb toPrimitive"}},[Symbol.toStringTag]:{value:function(){return"orb string tag"}}};W.self=()=>N;Object.defineProperty(W,Symbol.hasInstance,{value(q){return q&&Object.hasOwn(q,X)}});var m=function(q){return W(q)()};Object.defineProperty(m,Symbol.hasInstance,{value(q){return q&&q[U]&&q[U]instanceof P}});function $(q){return{def:q[R],models:q[X]}}export{$ as inspect,m as Orb,W as Model};
