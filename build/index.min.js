var x=function(W,B){let G=new Set([...W].filter((H)=>!B.has(H))),z=new Set([...B].filter((H)=>!W.has(H))),J={};Array.from([...B]).forEach((H)=>{if(H.indexOf(".")>0){let K=H.substring(0,H.indexOf(".")),U=H.substring(H.indexOf(".")+1);if(J[K])J[K].add(U);else J[K]=new Set([U]);z.delete(H)}});let q=Object.keys(J).map((H)=>[H,J[H]]);return[G,z,q]},F=0,Y=[],I=null,j="",D=Symbol("orbz-core");class A{#Y={};#Q={};#z={};#U=new Set;#A={};#J={};#V={};#B={};#q;#G=new Map;#W={};#H={};#F={};constructor(W,B,G){this.#q=G,this.#Y=W.orbs;for(let z in W.state)this.#W[z]=new Set,this.set_state(z,z in B?B[z]:W.state[z]);for(let z in W.orbs)this.#W[z]=new Set,this.set_orb(z,B[z]);for(let z in W.entry)this.#B[z]=W.entry[z].bind(this.#q);for(let z in W.async)this.#B[z]=W.async[z].bind(this.#q);for(let z in W.derived)this.#W[z]=new Set,this.#H[z]=new Set,this.#V[z]=W.derived[z].bind(this.#q);for(let z in W.getset)this.#W[z]=new Set,this.#H[z]=new Set,this.#V[z]=W.getset[z].get.bind(this.#q),this.#B[z]=W.getset[z].set.bind(this.#q)}add_link(W,B){let G=this.#F[W];return(z)=>{return G.add(z),()=>{G.delete(z)}}}add_sub(W,B){return this.#G.set(W,null),()=>{this.#G.delete(W)}}get_state(W){if(!W.startsWith("_")||this.#K())return this.#N(W),this.#Q[W]}set_state(W,B){if(!W.startsWith("_")||this.#K()){if(B!=this.#Q[W])this.#Q[W]=B,this.#T(W,!0),this.#X()}}get_derived(W){if(!W.startsWith("_")||this.#K()){this.#N(W);const B=I;let G;I=this;try{G=this.#I(W)}finally{I=B}return G}}run_entrypoint(W,B,{async:G=!1}={}){if(!W.startsWith("_")||this.#K()){if(this.#B[W]){if(!G)F++;let z=this.#B[W](...B);if(G)return z.then((J)=>{return this.#X(),J});else return F--,this.#X(),z}}}set_orb(W,B){let G=this.#Y[W];if(B&&B instanceof G)this.#z[W]=B;else if(B&&typeof B=="object")this.#z[W]=new G({...B});else this.#z[W]=null}get_orb(W){return this.#z[W]}#K(){return!0}#N(W){let B=Y.length;if(B!=0)Y[B-1].add(j+W),j=""}#P(){Y.push(new Set)}#R(){return Y.splice(Y.length-1,1)[0]}#I(W){if(this.#J[W])return this.#A[W];else{this.#P();let B=this.#H[W],G=this.#V[W](),z=this.#R(),[J,q,H]=x(B,z);return J.forEach((K)=>{this.#W[K].delete(W),this.#H[W].delete(K)}),q.forEach((K)=>{if(this.#W[K])this.#W[K].add(W);this.#H[W].add(K)}),H.forEach(([K,U])=>{this.#z[K].$((R)=>{})}),this.#A[W]=G,this.#J[W]=!0,G}}#T(W,B=!1){if(B||this.#J[W]){if(this.#U.add(W),!B)this.#J[W]=!1;this.#W[W].forEach((G)=>this.#T(G))}}#X(){if(F==0)this.#G.forEach((W,B)=>{if(W==null||[...W].some((G)=>this.#U.has(G))){W=new Set,this.#G.set(B,W),this.#P(),B(this.#q);let G=this.#R(),[z,J,q]=x(W,G);if(z.forEach((H)=>{W.delete(H)}),J.forEach((H)=>{W.add(H)}),q.forEach(([H,K])=>{}),W.size==0)this.#G.delete(B)}}),this.#U.clear()}}var Q=Symbol("orb-core"),E=Symbol("list-core"),N=Symbol("m-self"),Z=Symbol("orbz-ismodel"),P=Symbol("model-def"),X=Symbol("model-id"),T=Symbol("model-id");var V=function(){let{defs:W,types:B}=S(arguments[arguments.length-1]),G=Symbol("unique-model-id"),z=[G];for(let q=arguments.length-2;q>=0;q--)W=O(arguments[q][P],W),z.push(...arguments[q][X]);function J(q={}){if(!new.target)return new J(q);Object.defineProperty(this,Q,{value:new A(W,q,this)}),Object.defineProperty(this,T,{value:z}),Object.preventExtensions(this)}return Object.defineProperty(J,Symbol.hasInstance,{value:function(q){return q&&q[T]&&q[T].includes(G)}}),J[P]=W,J[X]=z,Object.keys(W.orbs).forEach((q)=>{if(W.orbs[q]==N)W.orbs[q]=J}),Object.keys(W.entry).forEach((q)=>{Object.defineProperty(J.prototype,q,{value:function(){return this[Q].run_entrypoint(q,arguments,{async:!1})}})}),Object.keys(W.async).forEach((q)=>{Object.defineProperty(J.prototype,q,{value:function(){return this[Q].run_entrypoint(q,arguments,{async:!0})}})}),Object.keys(W.derived).forEach((q)=>{Object.defineProperty(J.prototype,q,{get(){return this[Q].get_derived(q)},enumerable:!q.startsWith("_")})}),Object.keys(W.getset).forEach((q)=>{Object.defineProperty(J.prototype,q,{get(){return this[Q].get_derived(q)},set(H){return this[Q].run_entrypoint(q,[H])},enumerable:!q.startsWith("_")})}),Object.keys(W.state).forEach((q)=>{Object.defineProperty(J.prototype,q,{get(){return this[Q].get_state(q)},set(H){this[Q].set_state(q,H)},enumerable:!q.startsWith("_")})}),Object.keys(W.orbs).forEach((q)=>{Object.defineProperty(J.prototype,q,{get(){return this[Q].get_orb(q)},set(H){this[Q].set_orb(q,H)},enumerable:!q.startsWith("_")})}),Object.defineProperties(J.prototype,C),J},S=function(W){let B={state:{},derived:{},entry:{},orbs:{},getset:{},async:{}},G={},z=Object.getOwnPropertyDescriptors(W);return Object.keys(z).forEach((J)=>{let q,H,{value:K,get:U,set:R}=z[J];if(U&&R)q="getset",H={get:U,set:R};else if(U)H=U,q="derived";else if(R)console.log("TODO: lone setter");else if(H=K,typeof K=="function")if(K instanceof V)q="orbs";else if(K.constructor.name=="AsyncFunction")q="async";else q="entry";else if(K==N)q="orbs";else q="state";G[J]=q,B[q][J]=H}),{types:G,defs:B}},O=function(W,B){const G={...W,...B};for(let z of Object.keys(G))G[z]=typeof W[z]=="object"&&typeof B[z]=="object"?O(W[z],B[z]):G[z];return G},C={$:{value:function(W,B){if(typeof W=="function")return this[Q].add_sub(W,B);else if(typeof W=="string")return this[Q].add_link(W,B)}},$invalidate:{value:function(W){this[Q].inval(W)}},toString:{value:function(){return"orb toString"}},[Symbol.toPrimitive]:{value:function(){return"orb toPrimitive"}},[Symbol.toStringTag]:{value:function(){return"orb string tag"}}};V.self=()=>N;Object.defineProperty(V,Symbol.hasInstance,{value(W){return W&&Object.hasOwn(W,X)}});var m=function(W){return V(W)()};Object.defineProperty(m,Symbol.hasInstance,{value(W){return W&&W[Q]&&W[Q]instanceof A}});function $(W){return{def:W[P],models:W[X]}}export{$ as inspect,m as Orb,V as Model};
